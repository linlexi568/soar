"""AST-first pipeline utilities.

This module centralizes the conversion between external dict-style program
representation and internal AST-based rules used by MathProgramController.

Contract:
- External (for logs/storage/API): list[dict]
  * if/then form: {'if': {'condition': <AST-dict or simple cond>, 'then': [ ... ]}}
  * direct form (recommended): {'condition': AST-node, 'action': [BinaryOpNode('set', TerminalNode('u_*'), expr_ast), ...]}
  * legacy constant form (ultrafast vectorized): {'op':'set','var':'u_fz','expr':{'type':'const','value':0.3}}

- Internal (AST): list[{'condition': ProgramNode, 'action': list[ProgramNode]}]
  * action entries are BinaryOpNode('set', TerminalNode(var), expr)

Utilities:
- to_ast_program: best-effort convert external program to AST program
- to_serializable_dict: serialize AST program for logs/storage (uses serialization.py)
- has_u_set: quick check whether program produces any u_* outputs

Edge cases:
- If external program has no condition/action, we create a default "always true"
  condition (TerminalNode(1.0)) and keep actions empty unless we can infer constant sets.

"""
from __future__ import annotations
from typing import Any, Dict, List, Tuple

from .dsl import ProgramNode, TerminalNode, UnaryOpNode, BinaryOpNode, IfNode
from .serialization import serialize_ast

Rule = Dict[str, Any]
Program = List[Rule]

ALWAYS_TRUE: ProgramNode = TerminalNode(1.0)

# ---- Helpers to build AST nodes from simple dicts ----

def _ast_from_simple_expr(expr: Any) -> ProgramNode:
    """Best-effort construct AST from a simple JSON-friendly expression dict.
    Supported minimal subset:
    - {'type':'const','value':x}
    - {'type':'var','name': 'pos_err_x'}
    - {'type':'unary','op':'abs','child': {...}}
    - {'type':'binary','op':'+','left': {...}, 'right': {...}}
    Fallback: TerminalNode(0.0)
    """
    try:
        if not isinstance(expr, dict):
            return TerminalNode(0.0)
        t = expr.get('type')
        if t == 'const':
            return TerminalNode(float(expr.get('value', 0.0)))
        if t == 'var':
            return TerminalNode(str(expr.get('name', '')))
        if t == 'unary':
            return UnaryOpNode(expr.get('op', 'abs'), _ast_from_simple_expr(expr.get('child')))
        if t == 'binary':
            return BinaryOpNode(expr.get('op', '+'), _ast_from_simple_expr(expr.get('left')), _ast_from_simple_expr(expr.get('right')))
        # Some callers used {'left':var,'op':'set','right':expr}
        if t is None and 'op' in expr and expr.get('op') == 'set':
            left = expr.get('left')
            right = expr.get('right')
            left_ast = TerminalNode(str(left if isinstance(left, str) else ''))
            right_ast = _ast_from_simple_expr(right)
            return BinaryOpNode('set', left_ast, right_ast)
        return TerminalNode(0.0)
    except Exception:
        return TerminalNode(0.0)


def _infer_actions_from_legacy_set(rule: Dict[str, Any]) -> List[ProgramNode]:
    actions: List[ProgramNode] = []
    try:
        if rule.get('op') == 'set':
            var = str(rule.get('var', ''))
            expr = rule.get('expr', {})
            # Support const & var
            if isinstance(expr, dict):
                if expr.get('type') == 'const':
                    val = float(expr.get('value', 0.0))
                    actions.append(BinaryOpNode('set', TerminalNode(var), TerminalNode(val)))
                elif expr.get('type') == 'var':
                    nm = str(expr.get('name',''))
                    actions.append(BinaryOpNode('set', TerminalNode(var), TerminalNode(nm)))
            # Legacy tuple form: {'set': ('u_fz', 0.3)}
        elif 'set' in rule and isinstance(rule['set'], (list, tuple)) and len(rule['set'])>=2:
            var = str(rule['set'][0])
            val = float(rule['set'][1]) if isinstance(rule['set'][1], (int,float)) else 0.0
            actions.append(BinaryOpNode('set', TerminalNode(var), TerminalNode(val)))
    except Exception:
        pass
    return actions


def to_ast_program(program: Program) -> Program:
    """Convert external/legacy program list (including MCTS mutated dict rules) to AST-first form.

    Accepts two major formats:
      1. New/AST rules: {'condition': ProgramNode | expr_dict, 'action': [ProgramNode|expr_dict,...]}
      2. Legacy/MCTS JSON-ish: list of rule dicts each with:
           - 'condition': ProgramNode already (generated by MCTS) OR legacy expr dict
           - 'action': list of BinaryOpNode('set', TerminalNode(var), expr) already OR legacy {'op':'set','var':..., 'expr':{...}}
           - Older ultra-fast constant form: {'op':'set','var':'u_fz','expr':{'type':'const','value':0.3}}
           - If-form: {'if': {'condition': {...}, 'then': [ ... ]}}

    Returns uniform list[{'condition': ProgramNode, 'action': list[ProgramNode]}].
    Unknown entries are ignored.
    """
    ast_rules: Program = []
    if not program:
        return ast_rules

    for r in program:
        try:
            # Case 0: Raw MCTS rule already proper (condition is ProgramNode and actions are BinaryOpNode set)
            if (
                isinstance(r, dict) and 'action' in r and
                isinstance(r['action'], list) and isinstance(r.get('condition'), ProgramNode) and
                all(isinstance(a, ProgramNode) for a in r['action'])
            ):
                # Disable rule-level conditions: force unconditional execution
                ast_rules.append({'condition': ALWAYS_TRUE, 'action': r['action']})
                continue

            # Case 1: AST structure but with some action/cond still in dict simple form
            if isinstance(r, dict) and 'action' in r and isinstance(r['action'], list):
                # Disable rule-level conditions: force unconditional execution
                cond_node = ALWAYS_TRUE
                acts: List[ProgramNode] = []
                for a in r['action']:
                    if isinstance(a, ProgramNode):
                        acts.append(a)
                    elif isinstance(a, dict) and a.get('op') == 'set':
                        # unify legacy set style inside AST container
                        acts.extend(_infer_actions_from_legacy_set(a))
                    else:
                        acts.append(_ast_from_simple_expr(a))
                ast_rules.append({'condition': cond_node, 'action': acts})
                continue

            # Case 2: pure legacy set / simple rule (single action)
            if isinstance(r, dict) and r.get('op') == 'set':
                acts = _infer_actions_from_legacy_set(r)
                if acts:
                    ast_rules.append({'condition': ALWAYS_TRUE, 'action': acts})
                continue

            # Case 3: tuple based set wrapper {'set': ('u_fz', 0.3)}
            if isinstance(r, dict) and 'set' in r and isinstance(r['set'], (list, tuple)):
                acts = _infer_actions_from_legacy_set(r)
                if acts:
                    ast_rules.append({'condition': ALWAYS_TRUE, 'action': acts})
                continue

            # Case 4: if-then legacy wrapper
            if isinstance(r, dict) and 'if' in r:
                obj = r['if'] or {}
                # Disable rule-level conditions: force unconditional execution
                cond = ALWAYS_TRUE
                then_list = obj.get('then', []) or []
                acts: List[ProgramNode] = []
                for a in then_list:
                    if isinstance(a, dict) and a.get('op') == 'set':
                        acts.extend(_infer_actions_from_legacy_set(a))
                    else:
                        acts.append(_ast_from_simple_expr(a))
                ast_rules.append({'condition': cond, 'action': acts})
                continue
        except Exception:
            continue  # skip malformed rule
    return ast_rules


def has_u_set(ast_program: Program) -> bool:
    try:
        for r in ast_program:
            for a in r.get('action', []) or []:
                if isinstance(a, BinaryOpNode) and a.op=='set' and isinstance(a.left, TerminalNode):
                    k = str(a.left.value)
                    if k.startswith('u_') or k in ('m0','m1','m2','m3'):
                        return True
        return False
    except Exception:
        return False


def to_serializable_dict(ast_program: Program) -> Dict[str, Any]:
    """Serialize AST program with our existing serialization helpers."""
    out: List[Dict[str, Any]] = []
    for r in ast_program:
        acts = r.get('action', []) or []
        entry = {
            'action': [serialize_ast(a) for a in acts]
        }
        # Conditions are disabled, so we never serialize them
        out.append(entry)
    return {'rules': out}

__all__ = ['to_ast_program','to_serializable_dict','has_u_set']
