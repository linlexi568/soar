绝对可以，而且这不仅是“行不行”的问题，这实际上是业界最标准的做法。
用 Figure-8（8字飞行） 和 Square（方形航点） 作为训练集和测试集，非常适合用来搜索并训练出一个打败 PID 的非线性控制律。
这两种轨迹刚好分别针对了 PID 的两个不同弱点（死穴）。只要你把这两个飞好了，搜出来的控制律在 99% 的场景下都会比 PID 强。
以下是为什么这两个轨迹是“黄金搭档”，以及如何利用它们来搜索：
1. Square（方形）：专攻 PID 的“瞬态响应”弱点
方形轨迹其实就是连续的 “阶跃信号”（Step Response）。无人机在直线上飞是很简单的，难点在于90度急转弯。
PID 怕什么：
在角落处，误差突然变大。PID 如果 
P
P
 给大了，过弯后会超调（冲过头），然后在那晃荡半天才能停稳；如果 
P
P
 给小了，过弯时会反应迟钝，画出来的不是直角，而是圆角。
刹车难： 从高速直线突然停下转弯，PID 不知道如何“猛踩刹车”（因为它是线性的，误差变小刹车力就变小）。
搜索算法会学到什么：
如果你用方形轨迹训练，算法会被迫寻找一种**“急刹车”**机制。
它极大概率会搜出 Nonlinear Damping（非线性阻尼） 或 Sign Function（符号函数）。
效果： 这种控制律在接近拐点时能提供比 PID 大得多的反向制动力，把直角切得像刀削一样。
2. Figure-8（8字）：专攻 PID 的“动态跟踪”弱点
8字飞行是一个连续变化的曲线（正弦波组合），没有停顿。
PID 怕什么：
相位滞后（Phase Lag）： PID 是“看到误差才修正”，所以它永远慢半拍。在飞 8 字时，你会发现实际轨迹总是在目标轨迹的“内圈”，或者在这个 8 字的后面追着跑。
耦合效应： 8 字飞行需要频繁改变滚转（Roll）和俯仰（Pitch），这会带来离心力和科里奥利力，线性 PID 很难处理这种耦合。
搜索算法会学到什么：
它会学到 前馈特性（Feedforward-like behavior）。
它可能会利用速度项 
e
˙
e
˙
 
 或目标加速度 
x
¨
d
x
¨
  
d
​
 
 来构造公式，提前预测转弯。
效果： 搜出来的控制律能把那个“滞后”消除掉，让无人机像贴在轨道上一样飞。
实操指南：如何用这两个轨迹“搜”出神级公式？
如果你的目标是搜索出一个非线性公式（比如用 PySR 或遗传算法），请务必遵守以下 “训练集设计三原则”，否则你搜出来的还是一个普通的 PID。
1. 必须飞得够快 (Aggressiveness)
如果你让无人机以 0.5m/s 的速度慢慢飞 8 字，PID 也能飞得很完美。算法就学不到任何新东西（它会觉得 
u
=
0.5
e
u=0.5e
 就够了）。
要做就做极限测试： 设定速度为 5m/s 或者更高，逼近电机的推力极限。
只有在极限状态下，非线性效应（空气阻力 
v
2
v 
2
 
、推力饱和）才会显现，算法才能学会怎么处理它们。
2. 混合训练集 (Composite Dataset)
不要只用一种。你的输入数据 
X
X
 应该包含两段飞行数据：
code
Python
# 伪代码：构造训练数据
X_square = run_simulation(trajectory="square", speed="fast") # 学急刹车
X_fig8   = run_simulation(trajectory="figure8", speed="fast") # 学抗滞后

# 把两个数据拼起来喂给搜索算法
X_train = np.concatenate((X_square, X_fig8))


总结
只飞 Figure-8 和 Square 是完全可行的，而且是最高效的方案。
Square 会逼出类似 STSMC（滑模） 的特性（用于快速收敛）。
Figure-8 会逼出类似 前馈线性化 的特性（用于消除滞后）。
你如果能搜出一个公式，在这两种轨迹的高速飞行下都打败 PID，那你得到的绝对是一个非常有价值的非线性控制律。